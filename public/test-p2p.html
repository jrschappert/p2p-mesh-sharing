<!-- to run this test-p2p.html, run npx serve public -->
<!DOCTYPE html>
<html>
<head>
    <title>P2P Test</title>
    <style>
        .peer { margin: 20px; padding: 10px; border: 1px solid #ccc; }
        .log { height: 200px; overflow-y: scroll; background: #f0f0f0; padding: 8px; margin: 8px 0; }
    </style>
</head>
<body>
    <div class="peer" id="peer1">
        <h3>Peer 1 (Initiator)</h3>
        <button onclick="startPeer1()">Start Peer 1</button>
        <button onclick="connectToPeer2()">Connect to Peer 2</button>
        <div class="log" id="log1"></div>
    </div>
    <div class="peer" id="peer2">
        <h3>Peer 2</h3>
        <button onclick="startPeer2()">Start Peer 2</button>
        <div class="log" id="log2"></div>
    </div>

    <script type="module">
import { P2PClient } from '/src/P2PClient.js';

let peer1, peer2;
let myPeerId1, myPeerId2;

const AUTO_CONNECT = false; 
const SIGNALING_ORIGIN = 'http://localhost:3000';     // HTTP url for /peers
const SIGNALING_WS = 'ws://localhost:3000';          // WebSocket url
const MODEL_ID = 'test-model-1'; // set to true for demo auto-connect to first discovered peer

function log(peerNum, msg) {
  const logEl = document.getElementById(`log${peerNum}`);
  const line = document.createElement('div');
  line.textContent = `${new Date().toLocaleTimeString()} ${msg}`;
  logEl.appendChild(line);
  logEl.scrollTop = logEl.scrollHeight;
}

// new: show peer list in UI
function updatePeerListUI(peerNum, peers) {
  const containerId = peerNum === 1 ? 'peer1' : 'peer2';
  const container = document.getElementById(containerId);
  let list = container.querySelector('.peers-list');
  if (!list) {
    list = document.createElement('div');
    list.className = 'peers-list';
    container.appendChild(list);
  }
  list.innerHTML = `<b>Peers:</b> ${peers.map(p => `<span class="peer-id">${p.peerId}</span>`).join(', ')}`;
}

// return a signaling send function and also expose an onPeers callback
function createSignaling(peerId, onSignal) {
  const ws = new WebSocket(SIGNALING_WS);
  ws.onopen = () => {
    // Announce presence using the same MODEL_ID
    ws.send(JSON.stringify({
      type: 'announce',
      infoHash: MODEL_ID,
      from: peerId,
    }));
    log(peerId.startsWith('peer1') ? 1 : 2, 'Announced to signaling server');
  };
  ws.onmessage = (e) => {
    const msg = JSON.parse(e.data);
    log(peerId.startsWith('peer1') ? 1 : 2, `â† ${msg.type} from ${msg.from || 'server'}`);
    if (msg.type === 'peers') {
      log(peerId.startsWith('peer1') ? 1 : 2, `Known peers: ${msg.peers.map(p => p.peerId).join(', ')}`);
    } else if (['offer','answer','ice'].includes(msg.type)) {
      const type = msg.type === 'ice' ? 'ice-candidate' : msg.type;
      onSignal({ type, from: msg.from, to: peerId, data: msg.payload });
    }
  };
  ws.onerror = (err) => log(peerId.startsWith('peer1') ? 1 : 2, 'WS error: ' + String(err));
  return (msg) => {
    const type = msg.type === 'ice-candidate' ? 'ice' : msg.type;
    log(peerId.startsWith('peer1') ? 1 : 2, `â†’ ${type} to ${msg.to}`);
    ws.send(JSON.stringify({
      type,
      infoHash: MODEL_ID,
      from: msg.from,
      to: msg.to,
      payload: msg.data
    }));
  };
}

function createPeer(peerId, uiPeerNum) {
  const send = createSignaling(peerId,
    (msg) => peer.handleSignal(msg),
    (peers) => {
      updatePeerListUI(uiPeerNum, peers);
      // optionally auto connect to first other peer
      const other = peers.find(p => p.peerId !== peerId);
      if (AUTO_CONNECT && other) {
        log(uiPeerNum, `Auto-connecting to ${other.peerId}`);
        peer.connectTo(other.peerId);
      }
    },
    (info) => {
      // peer-joined callback
      log(uiPeerNum, `peer-joined: ${info.peerId}`);
    }
  );
  const peer = new P2PClient(peerId, send);

  peer.onChannelOpen = () => log(uiPeerNum, 'Data channel opened! ðŸŽ‰');
  peer.onChannelClose = () => log(uiPeerNum, 'Data channel closed');
  peer.onChannelError = (e) => log(uiPeerNum, `Data channel error: ${e}`);
  peer.onChannelMessage = (data) => {
    try {
      const msg = JSON.parse(data);
      log(uiPeerNum, `Received: ${JSON.stringify(msg)}`);
    } catch (e) {
      log(uiPeerNum, `Received: ${data}`);
    }
  };
  return peer;
}

// wire the buttons
window.startPeer1 = () => {
  myPeerId1 = 'peer1-' + Math.random().toString(36).slice(2, 7);
  peer1 = createPeer(myPeerId1, 1);
  log(1, `Started as ${myPeerId1}`);
};

window.startPeer2 = () => {
  myPeerId2 = 'peer2-' + Math.random().toString(36).slice(2, 7);
  peer2 = createPeer(myPeerId2, 2);
  log(2, `Started as ${myPeerId2}`);
};

window.connectToPeer2 = async () => {
  if (!peer1) { log(1, 'Start Peer 1 first'); return; }
  try {
    const res = await fetch(`${SIGNALING_ORIGIN}/peers?infoHash=${encodeURIComponent(MODEL_ID)}`);
    if (!res.ok) { throw new Error('HTTP ' + res.status); }
    const body = await res.json();
    log(1, `HTTP /peers => ${JSON.stringify(body.peers.map(p=>p.peerId))}`);
    const other = body.peers.find((p) => p.peerId !== peer1.localId && p.peerId !== undefined);
    if (!other) { log(1, 'No remote peer found via HTTP /peers'); return; }
    log(1, `Connecting to discovered peer ${other.peerId}`);
    await peer1.connectTo(other.peerId);
  } catch (e) {
    log(1, 'Error fetching peers: ' + String(e));
  }
};
</script>
